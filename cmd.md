# Инструкция для работы

git init             # создать новый проект в текущей директории.

git init folder-name # создать новый проект в указанной директории.

git status              # показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)

git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе

git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)

git clean -df              # удалить неотслеживаемые файлы и директории

git diff index.html     # сравнить файл из рабочей директории и индекс

git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --staged       # сравнить индекс и коммит с HEAD


git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master

git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов

git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master


git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий

git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)

git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов

git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании


## Выделение текста

Чтобы выделить текст курсивом нужно с двух сторон поставить звездочку (*) *Пример* или знак нижнего подчеркивания _ _ 

Полужирный двойная звездочка ** ** **Пример** или двойным знаком нижнего подчеркивания

два этих способа можно совмещать чтобы в предложении часть слов была курсивом, а часть полужирным (Жирным)

Зачеркнутый Двумя знаками тильда в начале и конце~ ~     ~~Пример~~ 

Заголовок # Перед словом до 6 знаков решетка  ###Пример

Полужирный курсив: три * вначале и конце  ***Пример***



## Работа с изображениями

Чтобы добавить фото в текст нужно написать ![Лучшее молоко](Рисунок1.png) 



## Списки

Нумерация списка в начале просто нумеруем цифрой с точкой

1. Цифра и точка)))
2. )))

Не нумерованные списки звездочка без точки

* Один

* Два


## Ссылки

## Таблицы

## Цитаты

<цитаты>

<<<чем больше уголков тем больше цитат>>>


## Ветки

git branch                 # показать список веток

            # показать список веток и последний коммит в каждой

git branch new_branch      # создать новую ветку с указанным именем на текущем коммите

git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите

git branch -f master 5589877  # переместить ветку master на указанный коммит

git branch -f master master~2 # переместить ветку master на 2 коммита назад

git checkout new_branch    # перейти в указанную ветку

git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё

git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё

git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix

git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)

git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов

git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния

git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)

git branch --merged        # показать ветки, уже слитые с активной

git branch --no-merged     # показать ветки, не слитые с активной

git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)

git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name

git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name

git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории

git branch --unset-upstream # завершить процесс переименования

«***Перенос***» ветки
Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

**Нельзя** «переносить» ветку, если она уже отправлена на удалённый репозиторий.

git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)

git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature

git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase

git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)

## Итого